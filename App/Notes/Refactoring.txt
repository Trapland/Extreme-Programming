Рефакторинг - внесення у код змін, які не змінюють функціонал
(поведінку) коду. Можна вважати поліморфізмом, так як зміни
із постійною алгоритмічною суттю. Якщо зміни вносяться в алгоритм
то це не є рефакторинг.
Мета: знайти найбільш оптимальну форму вираження коду.
 for(i:1..10) print(i)
 while(i<10) print(i++)
 do print(i++) while(i<10)
 print (i) { if(i==10) return ; else print(i+1)} - рекурсія
 range(10).forEach(print)
питання оптимальності є відкритим, тобто перед рефакторингом треба
вирішити. У XP це - простота (Simple design) - зрозумілість (всередині команди).
(+ стандарти кодування, + метафора системи)


Основні прийоми рефакторингу
Можна виділити окреми прийоми, але
 - не всі можливості рефакторингу будуть реалізовані (перебрані)
 - не багато прийомів мають протилежні значення (перенесення поля до батька/до нашадків)
 - прийоми парадигмо-орієнтовані (сильно залежать від парадигми, частіше ООП)

Боротьба з антипатернами
	- "Магічне число" - поява у коді числа (окрім 0 та 1), сенс якого незрозумілий
	(або неочевидний)
	int getRating(){
		return numberOfLateDeliveries > 5 ? 2 : 1;
	}
	- "Магічний рядок" - те ж саме, але з рядком, різновид "Hardcoded string"
	if ( login == "admin" ){ - "Магічний рядок"
		print("Hello") - Hardcoded string
	}
 - Це ж стосується і кольорів, поява імені чи коду кольору теж можна віднести
	до цих антипатернів

Можливі рішення:
 - "Магічне число":
  = Enum
	+ (для обмежених переліків: рейтинг)
	- (для неперервних даних: кількість протермінованих замовлень)
  = Константи
	+ іменування, розкриття сенсу (через ім'я)
	- зміни вимагають перекомпіляцію
  = Функція/метод
    + можливе для складних алгоритмів обчислення
  = Конфігурація (в окремому файлі)
	- можливість змін без перекомпіляції
	- можлвість втрат через видалення файлу
  = Провайдери-інжектори (інжекція залежностей)
	+ рекомендований підхід в ООП
	- ускладнення архітектури (додавання інжекторів)
  = Ресурси (окремі файли, які автоматично підключаються системою
	в залежності від умов/оточення запуску програми - ОС, мова, роздільна
	здатність, розмір/орієнтація екрану, тощо)
	+ автоматичні зміни, підходить для "Hardcoded string"
	- потреба різних ресурсів для різних умов оточення
Проблема: "роздутий" код(метод, клас, файл тощо)
Ознака (критерій): окремий блок коду можна поєднати своїм коментарем

class{
	method{						| region
		instruction		|		| for
		instruction		| algo	| smth
		instruction		| for	|
		instruction		| smth	|
		instruction		|		|
		instruction		|		|
	}							|
	method{						|
		instruction				|
		instruction				|
		instruction				|
	}							|
	method{						|
		instruction
		instruction
		instruction
	}
}

Альтернативні критерії: блок коду (метод, клас, файл)
не влазить на один "екран" (25-40 рядків)
- 7 +- 2
Критика: занадто розгалужений код, для розуміння цілісної картини
необхідно переглянути велику кількість файлів


Змішування алгоритмів (порушення Single Responsibility)
Ознака: в одному блоці вирішуються декілька задач (перевірка + дія)
for(item in items){
	if(item.name == null) ...
	else (widget.add(item) )
}
Наслідки: ускладнення змін однієї з задач, "зачіпання" іншої задачі
Рішення: розділення задач
Критика: збільшення працеємності, оскільки повторюються цикли та подібні конструкції

items = items.filter( item => item.name != null )
widget.addAll( items )
